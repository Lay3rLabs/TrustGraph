\section{Verifiable Services: Enabling New Governance Designs}

This section describes three primitives that lift the limits set in Section 2 while keeping verifiability. Trusted Execution Environments provide hardware-based guarantees of correct execution. Verifiable Services compose multiple operators—potentially running TEEs—into economically secured networks. Zero-knowledge proofs handle fixed computations that benefit from strong privacy or strict determinism. Hybrid architectures may leverage the strengths of each approach, promoting maximum verifiability, autonomy, and resilience.

\subsection{Trusted Execution Environments}

A Trusted Execution Environment (TEE) is a hardware-isolated region of a processor that executes code in a protected enclave. The hardware ensures that even the machine's owner cannot observe or tamper with computation inside the enclave. Remote parties can verify what code is running through cryptographic attestation.

\subsubsection{Core Properties}

TEEs provide three guarantees relevant to governance:

\begin{enumerate}
\item \textbf{Integrity:} Code running inside the enclave cannot be modified. The hardware prevents external interference, and attestation proves the exact binary being executed.
\item \textbf{Confidentiality:} Data inside the enclave remains encrypted in memory. Neither the operating system nor other processes can read enclave contents.
\item \textbf{Attestation:} The TEE generates cryptographic proofs that specific code is running on genuine hardware. Remote verifiers can confirm execution environment integrity before trusting outputs.
\end{enumerate}

For governance, these properties enable a distinct trust model. Rather than trusting operators to behave honestly (economic security) or verifying computation through proofs (cryptographic security), participants trust that hardware correctly executes attested software.

\subsubsection{Trust Model}

TEE security rests on different foundations than economic or cryptographic approaches:

\begin{itemize}
\item \textbf{Hardware root of trust:} Security derives from processor design and manufacturing. The hardware enforces isolation regardless of software-level attacks.
\item \textbf{Attestation verification:} Before accepting results, verifiers check that outputs came from genuine hardware running expected code. Attestation chains link outputs to specific software versions.
\item \textbf{Manufacturer trust:} The security model assumes hardware manufacturers have not introduced backdoors and that attestation keys remain uncompromised.
\item \textbf{Side-channel awareness:} While enclaves protect against direct observation, sophisticated attacks can infer information through timing, power consumption, or memory access patterns. Implementations must account for these vectors.
\end{itemize}

A single TEE provides strong guarantees that software executed correctly, but concentrates trust in one hardware instance and its manufacturer. This creates a spectrum of deployment options with different trust assumptions.

\subsubsection{Governance Applications}

TEEs enable governance patterns that benefit from execution integrity:

\begin{itemize}
\item \textbf{Confidential preference aggregation:} Collect votes inside an enclave that tallies results without exposing individual choices. Attestation proves the aggregation algorithm ran correctly.
\item \textbf{Sealed computation:} Execute sensitive logic—compensation calculations, eligibility checks, scoring algorithms—where even operators should not see intermediate values.
\item \textbf{Key management:} Governance keys can live inside enclaves, signing transactions only when attested code approves them. This enables automated execution without exposing keys to operators.
\item \textbf{Deterministic randomness:} Generate verifiable random values inside enclaves for tie-breaking, selection, or sampling. The hardware prevents manipulation while attestation proves the generation method.
\end{itemize}

\subsection{Verifiable Services}

A Verifiable Service (Sometimes called "Autonomous Verifiable Service" or "Network Extension") is a set of bonded operators that run agreed software off-chain and return results that on-chain contracts can check and accept. This approach builds on existing oracle designs while adding verifiable computation guarantees.

\subsubsection{Core Components}

The system has four parts:

\begin{enumerate}
\item \textbf{Operators:} The entities running the software, each bonded with stake that can be slashed for misbehavior
\item \textbf{Task specification:} The code to run, input requirements, and acceptance criteria encoded in a registry contract
\item \textbf{Execution and aggregation:} Operators fetch inputs, run tasks, and submit signed outputs
\item \textbf{Verification and settlement:} Contracts check outputs meet acceptance criteria, aggregate results, slash for failures
\end{enumerate}

For governance, operators might be established node runners, professional validators, or community-elected technical teams. Tasks could include preference aggregation, proposal quality scoring, or treasury rebalancing computations. The verification focuses on output consistency and timeliness rather than re-executing the computation.

\subsubsection{Trust Model}

Verifiable Services provide economic rather than cryptographic guarantees. Security comes from:

\begin{itemize}
\item \textbf{Multi-operator redundancy:} Multiple operators run the same task and must achieve threshold agreement (e.g., 3-of-5)
\item \textbf{Slashing for misbehavior:} Operators stake bonds that get slashed for submitting incorrect results or missing deadlines
\item \textbf{Deterministic software:} Tasks use fixed code versions, pinned dependencies, and deterministic execution to ensure reproducibility
\item \textbf{Auditability:} All inputs, outputs, and code are public, allowing anyone to verify correctness and dispute if needed
\end{itemize}

The economic security scales with the value at stake. For high-value governance decisions, larger bonds and more operators can be required. For routine operations, lighter requirements reduce cost.

\subsubsection{Example: Delegation Graph Resolution}

Consider liquid democracy with transitive delegation:

\begin{enumerate}
\item \textbf{Registry stores task:} ``Resolve delegation graph for proposal X using snapshot at block B''
\item \textbf{Operators fetch data:} Download delegation records and token balances at specified block
\item \textbf{Compute voting power:} Run graph traversal to resolve chains, detect cycles, aggregate weights
\item \textbf{Submit results:} Each operator signs and submits merkle root of voter weights
\item \textbf{Contract verifies:} Check 3-of-5 operators submitted matching roots within deadline
\item \textbf{Settlement:} Accept root, pay operators, slash any who submitted different results
\end{enumerate}

The computation that would cost millions in gas runs efficiently off-chain. The contract only verifies signatures and compares 32-byte roots. Voters can generate merkle proofs to claim their resolved voting power.

\subsection{Zero-Knowledge Proofs}

ZK proofs provide cryptographic guarantees that computation was performed correctly without revealing inputs or requiring re-execution. They are ideal for privacy-sensitive or standardized operations where the proof system's constraints are acceptable.

\subsubsection{Governance Applications}

Several governance patterns benefit from ZK:

\begin{itemize}
\item \textbf{Private voting:} Prove vote validity without revealing choice
\item \textbf{Eligibility checks:} Prove qualification (e.g., holding tokens, reputation score) without exposing exact amounts
\item \textbf{Aggregation:} Prove correct tallying of private inputs
\item \textbf{Compliance:} Prove proposals meet policy requirements without revealing sensitive details
\end{itemize}

For standardized computations with stable requirements, ZK provides stronger guarantees than economic security. The tradeoff is less flexibility—changing the circuit requires new trusted setup and deployment.

\subsubsection{Integration Points}

ZK proofs complement Verifiable Services:

\begin{itemize}
\item Services handle flexible, evolving logic
\item ZK handles fixed, privacy-sensitive operations
\item Services can generate and verify ZK proofs as part of larger workflows
\item Both feed minimal on-chain contracts that enforce governance decisions
\end{itemize}

\subsection{Hybrid Architecture}

The trust models—hardware, economic, and cryptographic—compose naturally, each addressing different failure modes. Production systems may combin multiple primitives.

The on-chain layer remains minimal. Contracts hold tokens, maintain registries of tasks and bonds, and verify outputs. Critical operations—asset transfers, permission changes—never leave smart contract control, protected by timelocks and dispute windows.

Off-chain, Verifiable Services handle complex computation: preference aggregation, proposal analysis, treasury rebalancing, cross-chain data collection. Operators can run inside TEEs for hardware integrity on top of economic bonds. TEEs also enable confidential computation—sensitive scoring algorithms, key custody, automated signing—where even operators cannot observe intermediate values. ZK proofs handle privacy-sensitive verification: private ballots, eligibility checks, compliance without disclosure.

The primitives reinforce each other. TEE-backed operators combine hardware and economic guarantees. Services may generate or verify ZK proofs as part of larger workflows. Economic bonds ensure liveness when cryptographic mechanisms ensure correctness.

If off-chain services fail, governance falls back to simple on-chain voting. The architecture degrades gracefully while preserving basic functionality.

The next sections show how verifiable offchain computation enables governance mechanisms previously impossible on-chain.
